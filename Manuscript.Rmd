---
title: "Missing The Point"
author: "Hanne Oberman"
date: "7-9-2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
load("~/MissingThePoint/Data/results_test.Rdata")

```

# Missing The Point: Non-Convergence in Iterative Imputation Algorithms

## Abstract

Iterative imputation is a popular tool to accommodate the ubiquitous problem of missing data. While it is widely accepted that this technique can yield valid inferences, these inferences all rely on algorithmic convergence. Our study provides insight into identifying non-convergence in iterative imputation algorithms, since there is no consensus on how to evaluate the convergence properties currently. We found that--in the cases considered--inferential validity was achieved after five to ten iterations, much earlier than indicated by diagnostic methods. We conclude that it never hurts to iterate longer, but such calculations hardly bring added value.

## Intro

Missing data poses a ubiquitous threat against unbiased, confidence-valid statistical inferences. A popular tool to accommodate missing data is iterative imputation. With techniques like multiple imputation (Rubin, 1987), missing data points are imputed (i.e., 'filled in')

- Missing data has to be accommodated, usually filled in

- Filling in is algorithmic, which relies on convergence

- Diagnosing convergence is difficult, both visually and diagnostically

- In this paper we explore diagnostic methods for MICE, and show which parameter has the best performance --> most informative about convergence 


## Identifying non-convergence

- What does non-convergence look like? What are the consequences?

- 


## Simulation

- 3x3 missingness conditions: MCAR, MAR, MNAR + 5, 50, 95% of cases incomplete

- outcomes: estimated regression coefficient, CIW, coverage, R2 --> multivariate is key, because univariate convergence does not guarantee multivariate convergence

- convergence parameters: chain means, chain variances, scientific parameter, lambda

- diagnostics: rhat, ac

## Some results

```{r echo=FALSE}
results %>%
  ggplot() +
  #geom_hline(yintercept = 0.3334) +
  geom_point(aes(x=it, y=est, color = mech, shape = as.factor(p))) +
  geom_line(aes(x=it, y=est, color = mech, linetype = as.factor(p))) +
  theme_classic()


```

Bias in estimate depends mostly on the amount of missingness (less info to estimate the relation??), but overall MNAR performs the worst, which is stable after it=5.

Update with different CI computation, see https://stefvanbuuren.name/fimd/sec-evaluation.html#sec:quantifyingbias

```{r}
results %>% #filter(it>6) %>% 
  ggplot() +
  geom_hline(yintercept = 0.95, size = 2, color = "grey") +
  geom_point(aes(x=it, y=cov, color = mech, shape = as.factor(p))) +
  geom_line(aes(x=it, y=cov, color = mech, linetype = as.factor(p))) +
  theme_classic()


```

Cov is more or less fine, except for MNAR with only 0.05% incomplete cases --> due to bias in the estimate in combination with very narrow CI (see CIW!). However, all stable after it=3??

```{r}
results %>%
  ggplot() +
  geom_point(aes(x=it, y=CIW, color = mech, shape = as.factor(p))) +
  geom_line(aes(x=it, y=CIW, color = mech, linetype = as.factor(p))) +
  theme_classic()


```

CIW clearly determined by the proportion of incomplete cases. Worst for p=0.95, then stable after it 7.

```{r}
results %>% 
  # filter(it>6) %>% 
  ggplot() +
  geom_point(aes(x=it, y=rsq, color = mech, shape = as.factor(p))) +
  geom_line(aes(x=it, y=rsq, color = mech, linetype = as.factor(p))) +
  theme_classic()

```

Magnitude of the bias in R^2 perfectly follows the missingness mechanisms: least bias for MCAR, most for MNAR. Worst effect of non-convergence for p=0.95, MNAR, but stable from it=5.

```{r}
results %>%
  ggplot() +
  geom_point(aes(x=it, y=ac.max.mu.Y, color = mech, shape = as.factor(p))) +
  geom_line(aes(x=it, y=ac.max.mu.Y, color = mech, linetype = as.factor(p))) +
  theme_classic()
```


```{r}
results %>%
  ggplot() +
  geom_point(aes(x=it, y=r.hat.max.mu.Y, color = mech, shape = as.factor(p))) +
  geom_line(aes(x=it, y=r.hat.max.mu.Y, color = mech, linetype = as.factor(p))) +
  theme_classic()

```

```{r}
results %>%
  ggplot() +
  geom_point(aes(x=it, y=ac.max.sigma.Y, color = mech, shape = as.factor(p))) +
  geom_line(aes(x=it, y=ac.max.sigma.Y, color = mech, linetype = as.factor(p))) +
  theme_classic()
```


```{r}
results %>%
  ggplot() +
  geom_point(aes(x=it, y=r.hat.max.sigma.Y, color = mech, shape = as.factor(p))) +
  geom_line(aes(x=it, y=r.hat.max.sigma.Y, color = mech, linetype = as.factor(p))) +
  theme_classic()

```

```{r}
results %>%
  ggplot() +
  geom_point(aes(x=it, y=ac.max.qhat, color = mech, shape = as.factor(p))) +
  geom_line(aes(x=it, y=ac.max.qhat, color = mech, linetype = as.factor(p))) +
  theme_classic()
```


```{r}
results %>%
  ggplot() +
  geom_point(aes(x=it, y=r.hat.max.qhat, color = mech, shape = as.factor(p))) +
  geom_line(aes(x=it, y=r.hat.max.qhat, color = mech, linetype = as.factor(p))) +
  theme_classic()

```


```{r}
results %>%
  ggplot() +
  geom_point(aes(x=it, y=ac.max.lambda, color = mech, shape = as.factor(p))) +
  geom_line(aes(x=it, y=ac.max.lambda, color = mech, linetype = as.factor(p))) +
  theme_classic()
```


```{r}
results %>%
  ggplot() +
  geom_point(aes(x=it, y=r.hat.max.lambda, color = mech, shape = as.factor(p))) +
  geom_line(aes(x=it, y=r.hat.max.lambda, color = mech, linetype = as.factor(p))) +
  theme_classic()

```

## Discussion

- Estimates etc do not improve after it = 7

- Convergence diagnostics keep improving, but are all stable after 20-30 it

- Univariate thetas do not differentiate between missingness mechanisms or proportions of incomplete cases

- Determining non-stationarity with lambda is more difficult than with qhat :(

## Check if heuristic for AC works
```{r}
# load("~/MissingThePoint/Data/diagnostics.Rdata")
# load("~/MissingThePoint/Data/raw_outcomes.Rdata")
sim_nr <- 3
outcomes[[sim_nr]] %>% filter(mech == "MCAR", p == 0.95) %>% ggplot(aes(x=it, y = est)) + geom_line()
convergence_diagnostics %>% filter(sim == sim_nr, mech == "MCAR", p ==0.95) %>% ggplot(aes(x=it, y = ac.max.qhat)) + geom_line()
convergence_diagnostics %>% filter(sim == sim_nr, mech == "MCAR", p ==0.95) %>% ggplot(aes(x=it, y = ac.max.lambda)) + geom_line()
```

## Example data

```{r}
# environment
library(mice)
set.seed(123)

# functions
source("~/MissingeThePoint/R/ComputeDiagnostics.R")

not_all_na <- function(x) {
  !all(is.na(x))
}

preprocess_thetas <- function(theta, ext){
  out <- theta %>% 
  as.data.frame() %>% 
  t() %>% 
  as.data.frame() %>%
        setNames(paste0(ext, ".", names(.))) %>%
        cbind(
          it = 1:n_it,
          m = rep(1:n_imp, each = n_it),
          .
        ) %>% 
    select_if(not_all_na) %>% 
    arrange(it)
  rownames(out) <- NULL
  return(out)
}

get_diagnostics <- function(parameters) {
  thetas <- names(parameters)[-c(1:2)]
  out <- purrr::map_dfc(thetas, function(tt) {
    matrix(parameters[[tt]], ncol = n_imp, byrow = T) %>%
      convergence() %>%
      select(r.hat.max, ac.max) %>%
      setNames(., paste0(names(.), ".", tt))
  }) %>%
    cbind(it = 1:n_it, .)
  return(out)
}

impute_once <- function(iteration, ...) {
  if(is.null(mids)){
    mids <<- mice(boys, m = n_imp, maxit = 1, printFlag = FALSE)
  }
  else {
    mids <<- mice.mids(mids, printFlag = FALSE)
  }
  mira <- mids %>% mice::lm.mids(age ~ ., data = .) 
  mipo <- mira %>%
    mice::pool() %>%
    summary(., conf.int = TRUE)
  out <- data.frame(it = iteration, est = mipo[["estimate"]][2])
  return(out)
}

# parameters
n_imp <- 5
n_it <- 10

# analyses
mids <- NULL
ests <- purrr::map_dfr(1:n_it, function(it){impute_once(iteration = it)})
param <- preprocess_thetas(mids$chainMean, ext = "mu") %>% 
  dplyr::full_join(
      preprocess_thetas(mids$chainVar, ext = "sigma")
  )
convs <- get_diagnostics(param)
res <- full_join(ests, convs)
# plot
ggplot(conv, aes(x = it, y = ac.max.mu.hgt)) +
  geom_line()

# more analyses
imp2 <- mice(boys, m = n_imp, maxit = 1, printFlag = FALSE, seed = 123)
mice.mids(imp2)
```

