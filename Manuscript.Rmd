---
title: "Missing The Point"
author: "Hanne Oberman"
date: "7-9-2020"
output: html_document
---

```{r setup, include=FALSE}
# environment
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(mice)
load("Data/results.Rdata")

# sim results plotting function
generic_plot <- function(v, name, ...){
  results %>%
    mutate(
      p = factor(p, levels = c(0.05, 0.5, 0.95), labels = c("5%", "50%", "95%")),
      mech = factor(mech, levels = c("MCAR", "MAR", "MNAR"))
      ) %>% 
  ggplot(aes(
    x=.data[["it"]], 
    y=.data[[v]], 
    color = .data[["p"]], 
    shape = .data[["mech"]], 
    linetype = .data[["mech"]]
    )) +
  geom_line(na.rm = TRUE) +
  labs(
    x = "Number of iterations",
    y = name,
    color = "Incomplete \n cases", 
    shape = "Missingness \n mechanism", 
    linetype = "Missingness \n mechanism") +
  theme_classic() + 
  scale_color_manual(values = c(
    #"#009E73", #green
    "#56B4E9", #blue
    #"#E69F00", #orange
    "#F0E442", #yellow
    "#D55E00"  #red
  ))
  # scale_color_manual(values = c(
  #   # '#228833', #green
  #   # '#66CCEE', #blue
  #   '#CCBB44', #yellow
  #   '#EE6677',  #red~ish
  #   '#AA3377'  #maroon
  #   ))
}
```

# Missing The Point: Non-Convergence in Iterative Imputation Algorithms

## Abstract

Iterative imputation is a popular tool to accommodate the ubiquitous problem of missing data. While it is widely accepted that this technique can yield valid inferences, these inferences all rely on algorithmic convergence. Our study provides insight into identifying non-convergence in iterative imputation algorithms, since there is no consensus on how to evaluate the convergence properties currently. We found that--in the cases considered--inferential validity was achieved after five to ten iterations, much earlier than indicated by diagnostic methods. We conclude that it never hurts to iterate longer, but such calculations hardly bring added value.

## Intro

Missing data poses a ubiquitous threat against unbiased, confidence-valid statistical inferences. A popular tool to accommodate missing data is iterative imputation. With techniques like multiple imputation (Rubin, 1987), missing data points are imputed (i.e., 'filled in')

- Missing data has to be accommodated, usually filled in

- Filling in is algorithmic, which relies on convergence

- Diagnosing convergence is difficult, both visually and diagnostically

- In this paper we explore diagnostic methods for MICE, and show which method (parameter + diagnostic + threshold) is the most informative about convergence 


## Identifying non-convergence

- What does non-convergence look like? What are the consequences? Refer to van Buuren (2018) instead of reproducing it. 

- 


## Simulation

- 3x3 missingness conditions: MCAR, MAR, MNAR + 5, 50, 95% of cases incomplete

- outcomes: estimated regression coefficient, CIW, coverage, R2 --> multivariate is key, because univariate convergence does not guarantee multivariate convergence

- convergence parameters: chain means, chain variances, scientific parameter, lambda

- diagnostics: rhat, ac

## Some results

```{r echo=FALSE}
generic_plot(v = "est", name = "Regression estimate") + 
  list(geom_hline(yintercept = 1, color = "grey"))

```

Bias in estimate depends mostly on the amount of missingness (less info to estimate the relation??), but overall MNAR performs the worst, which is stable after it=5.

Update with different CI computation, see https://stefvanbuuren.name/fimd/sec-evaluation.html#sec:quantifyingbias

```{r echo=FALSE}
generic_plot( v ="cov", name = "Coverage rate") + 
  list(geom_hline(yintercept = 0.95, color = "grey"))

# generic_plot( v ="cov", name = "Coverage rate") + 
#   list(geom_hline(yintercept = 0.95, color = "grey")) +
#   ylim(0.85, 1)

```

Cov is more or less fine, except for MNAR with only 0.05% incomplete cases --> due to bias in the estimate in combination with very narrow CI (see CIW!). However, all stable after it=3??

```{r echo=FALSE}
generic_plot(v="CIW", name = "CI width") 

```

CIW clearly determined by the proportion of incomplete cases. Worst for p=0.95, then stable after it 7.

```{r echo=FALSE}
generic_plot(v="rsq", name = "Coefficient of determination (r^2)") +
  list(geom_hline(yintercept = 0.5, color = "grey"))

```

Magnitude of the bias in r^2 perfectly follows the missingness mechanisms: least bias for MCAR, most for MNAR. Worst effect of non-convergence for p=0.95, MNAR, but stable from it=5.

```{r echo=FALSE}
generic_plot(v="ac.max.mu.Y", name = "AC chain means") 

```

This plot above and the next three plots show autocorrelations with different thetas

```{r echo=FALSE}
generic_plot(v="ac.max.sigma.Y", name = "AC chain variances") 

```

```{r echo=FALSE}
generic_plot(v="ac.max.qhat", name = "AC scientific estimate") 

```

```{r echo=FALSE}
generic_plot(v="ac.max.lambda", name = "AC novel theta") 

```

```{r echo=FALSE}
generic_plot(v="r.hat.max.mu.Y", name = "R hat chain means") 

```

This plot above and the next three plots show r hat values with different thetas

```{r echo=FALSE}
generic_plot(v="r.hat.max.sigma.Y", name = "R hat chain variances") 

```

```{r echo=FALSE}
generic_plot(v="r.hat.max.qhat", name = "R hat scientific estimate") 

```

```{r echo=FALSE}
generic_plot(v="r.hat.max.lambda", name = "R hat novel theta") 

```

These rhat plots all show some initialization before the fifth iteration: is rhat usefull before that??

## Discussion

- Estimates etc do not improve after it = 7

- Convergence diagnostics keep improving, but are all stable after 20-30 it

- Univariate thetas do not differentiate between missingness mechanisms or proportions of incomplete cases

- Determining non-stationarity with lambda is more difficult than with qhat :(

<!-- ## Check if heuristic for AC works -->
<!-- ```{r} -->
<!-- load("Data/diagnostics.Rdata") -->
<!-- load("Data/raw_outcomes.Rdata") -->
<!-- sim_nr <- 3 -->
<!-- outcomes[[sim_nr]] %>% filter(mech == "MCAR", p == 0.95) %>% ggplot(aes(x=it, y = est)) + geom_line() -->
<!-- convergence_diagnostics %>% filter(sim == sim_nr, mech == "MCAR", p ==0.95) %>% ggplot(aes(x=it, y = ac.max.qhat)) + geom_line() -->
<!-- convergence_diagnostics %>% filter(sim == sim_nr, mech == "MCAR", p ==0.95) %>% ggplot(aes(x=it, y = ac.max.lambda)) + geom_line() -->
<!-- ``` -->

## Example data

```{r}
# load data
load("Data/example.Rdata")
load("Data/example_mids.Rdata")

# plot each var of example data
plotfun <- function(v, ...){
ggplot(example, aes(x = .data[["it"]], y = .data[[v]])) +
  geom_line() +
  theme_classic()
}

plotfun(v="est")
plotfun(v="ac.max.qhat")
plotfun(v="ac.max.lambda")
plotfun(v="r.hat.max.qhat")+list(geom_hline(yintercept = 1.2, color = "grey"))
plotfun(v="r.hat.max.lambda")+list(geom_hline(yintercept = 1.2, color = "grey"))

plot(mids)
```

